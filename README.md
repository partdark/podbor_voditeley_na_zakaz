# Подбор ближайших водителей на заказ

Этот проект представляет собой решение задачи по поиску ближайших водителей для поступившего заказа.

## Описание задачи

Необходимо реализовать механизм подбора водителя на заказ на прямоугольной карте размером `N*M`. Координаты водителей и заказов представлены в виде `(X, Y)`.

**Основные требования:**
1.  Реализовать три или более различных алгоритма для поиска **пяти** ближайших к заказу водителей.
2.  Сравнить производительность реализованных алгоритмов с помощью библиотеки `BenchmarkDotNet`.
3.  Покрыть разработанные алгоритмы тестами, используя фреймворк `NUnit`.
4.  Добавить скриншоты с результатами бенчмарков в этот `README.md` файл.

## Реализованные алгоритмы

В рамках проекта было реализовано три различных подхода к решению задачи.

### 1. Полный перебор с сортировкой (`FindNearest_1`)

Простейший алгоритм, который выполняет следующие шаги:
-   Для каждого водителя из списка вычисляется квадрат евклидова расстояния до точки заказа.
-   Весь список водителей сортируется по возрастанию этого расстояния.
-   Из отсортированного списка выбираются первые 5 водителей.

**Преимущества:** Простота реализации.
**Недостатки:** Низкая производительность на больших наборах данных из-за необходимости сортировки всего списка водителей (сложность `O(D * log D)`, где `D` - количество водителей).

### 2. Использование `PriorityQueue` (`FindNearest_2`)

Этот алгоритм использует `PriorityQueue` для поддержания списка из 5 самых дальних водителей из уже проверенных.

**Преимущества:** Более эффективен, чем полная сортировка.

### 3. Алгоритм на основе сетки (`FindNearest_3`)

Наиболее сложный и потенциально самый производительный алгоритм для больших и плотных наборов данных.
-   Карта делится на ячейки (grid).
-   Все водители распределяются по этим ячейкам в `Dictionary<Point, List<Driver>>`.
-   Поиск начинается с ячейки, в которой находится заказ.
-   Затем поиск расширяется по спирали (кольцами) к соседним ячейкам.
-   Используется `PriorityQueue` (как max-heap с отрицательными приоритетами) для хранения 5 ближайших найденных кандидатов.
-   Поиск прекращается, когда минимальное возможное расстояние до водителей в необследованных ячейках становится больше, чем максимальное расстояние до уже найденных 5 кандидатов.

**Преимущества:** Высокая производительность на больших и равномерно распределенных наборах данных, так как не требуется проверять всех водителей.
**Недостатки:** Сложность реализации; производительность может снижаться при неравномерном распределении водителей.

## Тестирование

Все три алгоритма покрыты набором тестов с использованием фреймворка **NUnit**. Тесты проверяют корректность работы алгоритмов на различных входных данных, включая пограничные случаи (например, отсутствие водителей).

## Сравнение производительности

Для сравнения производительности использовалась библиотека **BenchmarkDotNet**.
![Иллюстрация к проекту](https://github.com/partdark/podbor_voditeley_na_zakaz/blob/master/tests.png)
